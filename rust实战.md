# 1.rust的声明式宏和java的注解有些相似会在编译时略过，rust有两个解析器一个用于常规语法，一个用于宏的解析。在编译过程中rust会先编译普通语法生成ast,遇到宏会略过，但是会在ast做标记节点，当正常语法编译完成之后。会使用宏编译器展开宏代码，完成整个编译过程。

# 2.分号表达式只会在块表达式的最后一行才会计算，其他分号都是作为连接符号存在

# 3.rust语言一切皆是表达式，除了属性声明以外

# 4.rust的编译期计算
过程宏+build脚本
常量表达式

# 5.常量传播
比如吧程序里面所有3+4的地方替换成7，避免重复计算。

# 6.加";"是语句，不加是表达式。语句没有返回值。

# 7.表达式分为位置表达式（左值）或者值表达式（右值）

## 位置表达式
1.静态变量的初始化
2.解引用表达式（*expr）
3.数组索引表达式（exor[expr]）
4.字段表达式expr.field
5.以及加上口号的位置表达式

除此之外都是值表达式

基本数据类型可以存储在栈上 拥有copy语义，给另一个变量赋值是是赋值一份，所以原变量还可以使用

字符串在运行时可动态增长，所以存储在堆上，所以原变量是一个指向堆内存的指针，所以赋值给另外一个变量值就是移动，因为赋值的话就相当于两个指针指向了同一块内存。

# 8.不可变和可变
变量默认不可变，加mut可变

# 9.数据类型
1.基本数据类型

    结构体分为：
        具名结构体
        元组结构体
        单元结构体

rust也会自动对齐结构体

#[repr]内存布局的开关，用了就不会优化了

内部可变性容器和继承式可变性相对应

cell容器让不可变，变得可变，就是把* mut T给你。
用过使用了 x.into_inner(); 之前的容器就无法使用了，这个方法是退出容器。

# 10.类型行为
这个说的就是这个结构体（或者说类型做什么好，可以说是接口吧，限定了类型的动作）

trait的孤儿规则：trait或者类型，必须有一个在本地定义，这个本地我理解为当前.rs文件。

仿射类型：标记一种表示内存和资源，最多只能被使用一次。

rust内置的trait分类

所有权：copy ,unpin,drop
并发：sync,send
大小：size
默认值：default
智能指针：deref
类型转换：From,into,AdRef

# 11.函数

常规函数

函数指针

闭包

1.未捕获环境变量的闭包是函数指针类型
2.捕获了环境变量的才是闭包类型

FnOnce代表所有权

FnMut可变的借用

Fn不可变的借用

闭包的特殊情况
1.逃逸闭包与非逃逸闭包

闭包作为函数返回，不在函数结束完成后销毁就是逃逸闭包，否则就是非逃逸闭包。

2.唯一不可变借用

3.闭包自身实现那些trait

# 12.关于rust中的模式匹配
1.let声明

2.函数和闭包参数

3.match表达式

4.if let表达式

5.while let表达式

6.for表达式

关于ref
就是引用的意思
let a=42;
let ref b=a;
let c=&a;

第二句等价于第三句
ref b的类型为 &i32

match表达式

当引用和非引用匹配的时候编译器会自动添加ref

# 智能指针
safe rust里面只有 box可以在堆上申请内存

# 字符与字符串

str是切片类型

# 集合容器
1.Vec<T> 动态数组
2.VecDeque<T> 基于环形缓冲的先进先出的双端队列
3.LinkedList<T> ,非侵入式双向链表实现
等等

胖指针:一个指针加上这个指针指向的数据的长度就是一个胖指针









